/*
 * Copyright (C) 2007-2010 Inverse inc. and Ludovic Marcotte
 * 
 * Author: Ludovic Marcotte <lmarcotte@inverse.ca>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package ca.inverse.sogo.engine.source;

import com.funambol.common.pim.calendar.Task;
import com.funambol.common.pim.calendar.Calendar;
import com.funambol.common.pim.common.Property;
import com.funambol.common.pim.contact.Contact;
import com.funambol.framework.engine.source.SyncContext;
import com.funambol.framework.logging.FunambolLogger;

public class SOGoSanitizer {

	/**
	 * This method is used to fix the input we're getting FROM various
	 * clients in order to avoid exceptions being generated by Funambol
	 * upon parsing.
	 * 
	 * @param bytes
	 * @return
	 */
	public static String sanitizevCalendarInput(byte[] bytes, String key, FunambolLogger log) {
		String delim, s, lines[];
		StringBuffer buf;
		int a, i, len;
		boolean b;
		
		buf = new StringBuffer(new String(bytes));
		b = false;
		
		// We check to see how do we split our lines, using \r\n or simply \n.
		if (buf.toString().indexOf("\r\n") >= 0) {
			delim = "\r\n";
		} else {
			delim = "\n";
		}
				
		s = buf.toString();
		
		// We replace TRANSP:OPAQUE / TRANSPARENT with the appropriate integer value.
		// This will otherwise cause issues in SyncJe > v2.34
		s = s.replace("TRANSP:OPAQUE", "TRANSP:0");
		s = s.replace("TRANSP:TRANSPARENT", "TRANSP:1");
		
		// We replace any non-short value for X-MICROSOFT-CDO-BUSYSTATUS with
		// the appropriate short value. If we don't do that, an exception
		// will be raised in Funambol <= 6.5. We use the following mapping:
		// FREE             -> 0   
		// TENTATIVE        -> 1
		// BUSY             -> 2
		// UNAVAILABLE, OOF -> 3 (OOF seems to mean "Out of office" but isn't documented)
		s = s.replace("X-MICROSOFT-CDO-BUSYSTATUS:FREE", "X-MICROSOFT-CDO-BUSYSTATUS:0");
		s = s.replace("X-MICROSOFT-CDO-BUSYSTATUS:TENTATIVE", "X-MICROSOFT-CDO-BUSYSTATUS:1");
		s = s.replace("X-MICROSOFT-CDO-BUSYSTATUS:BUSY", "X-MICROSOFT-CDO-BUSYSTATUS:2");
		s = s.replace("X-MICROSOFT-CDO-BUSYSTATUS:UNAVAILABLE", "X-MICROSOFT-CDO-BUSYSTATUS:3");
		s = s.replace("X-MICROSOFT-CDO-BUSYSTATUS:OOF", "X-MICROSOFT-CDO-BUSYSTATUS:3");
		
		// do all cleanup of AALARM entries in separate function:
		s = aAlarmCleanup(s,log);
		
		// We "uppercase" encoding=, otherwise, Funambol won't 
		// even recognize it.
		s = s.replace("encoding=QUOTED-PRINTABLE", "ENCODING=QUOTED-PRINTABLE");
		
		// HACK: NextHaus SyncJe 2.32 does NOT fold lines properly. In order for
		//       us to not break on this (well, not us but Funambol), we re-fold
		//       the lines properly. This is _SLOW_ but can't be avoided for now.
		buf = new StringBuffer();
		lines = s.split(delim);
		
		for (i = lines.length-1; i >= 0; i--) {
			
			s = lines[i];

			// We strip the DTSTAMP attributes since SyncJe doesn't also like them
			// very much...
			if (s.startsWith("DTSTAMP:")) continue;
			
			if (s.startsWith("UID:")) b = true;
			
			// We strip empty RRULE. The Funambol Outlook Connector generates
			// empty RRULE for new events - and this confuses clients such as SyncJe.
			if (s.startsWith("RRULE:") && s.length() == 6) continue;			
			
			buf.insert(0, delim);
			buf.insert(0, s);
						
			if (lines[i].length() > 0 && lines[i].charAt(0) != ' ') {
				if (i >= 1 && (len = lines[i-1].length()) > 0 && lines[i-1].charAt(len-1) == '=') {
					if (lines[i-1].startsWith("ATTENDEE")) {
						s = lines[i-1];						
						// We strip the trailing = of the last line
						s = s.substring(0, s.length()-1);
						buf.insert(0, s);
						i--;
					} else {
						buf.insert(0, ' ');	
					}
				}
			}
		}
		
		// HACK: Synthesis SyncML does NOT send UID fields and this prevents
		//		 events from being modified by Mozilla Lightning. We add
		//       it if not present based on our item key.
		s = "UID:" + key + delim;
		if (!b) {
			a = buf.indexOf("BEGIN:VEVENT");
			if (a >= 0) {
				buf.insert(a+12+delim.length(), s);
			} else {
				a = buf.indexOf("BEGIN:VTODO");
				buf.insert(a+11+delim.length(), s);
			}
			
		}
		
		return buf.toString();
	}
	
	/*
	 *  This is a rather brute force cleanup for AALARM lines.
	 *	
	 * it converts e.g the following lines (which all caused parser
	 * exceptions)
  	 *
	 * AALARM;TYPE=X-EPOCSOUND:20091225T124500;;;
	 * AALARM;TYPE=X-EPOCSOUND;ENCODING=QUOTED-PRINTABLE:20091225T124500;;;z:=5Csystem=5CSystemSounds=5Calarm.wav
	 * AALARM;CHARSET=UTF-8:20091225T124500;;;
	 * 
	 * to a simple
	 *	 
	 * AALARM:20091225T124500
	 */
	public static String aAlarmCleanup(String s, FunambolLogger log) {
		
		log.info("in aAlarmCleanup(), s on input is:".concat(s));
		String ret, delim, line, lines[], chunk, chunks[], parts[], alarmdate;;
		
		alarmdate = null;
		ret = "";
		
		try {
			// We check to see how do we split our lines, using \r\n or simply \n.
			if (s.indexOf("\r\n") >= 0) {
				delim = "\r\n";
			} else {
				delim = "\n";
			}
			lines = s.split(delim);
			for (int i = 0; i <= lines.length - 1; i++) {

				line = lines[i];

				// find the AALARM line:
				if (line.startsWith("AALARM")) {
					// log.info("found AALARM line:".concat(line));
					// split into ";" delimited chunks:
					chunks = line.split(";");//
					for (int j = chunks.length - 1; j >= 0; j--) {
						chunk = chunks[j];
						// log.info("found chunk:".concat(chunk));
						// try splitting a chunk into key:value parts:
						parts = chunk.split(":");
						if (parts.length == 2) {
							log.info("found part[1]=".concat(parts[1]));
							if (parts[1].matches("[0-9]{8}T[0-9]{6}Z*")) {
								alarmdate = parts[1];
								log.info("found an alarmdate:"
										.concat(alarmdate));
							}
						}
					}
					// construct simplified AALARM line:
					if (alarmdate != null)
						ret = ret.concat("AALARM:").concat(alarmdate).concat(
								delim);
				} else {
					// log.info("line:".concat(line));
					// leave untouched:
					ret = ret.concat(line).concat(delim);
				}
			}
		} catch (Exception e) {
			log.error("Exception occured in aAlarmCleanup(): " + e.toString(), e);
			return s;
		}
		log.info("after aAlarmCleanup(), ret value is:".concat(ret));

		return ret;
	}

	/**
	 * 
	 * @param bytes
	 * @param key
	 * @return
	 */
	public static String sanitizevCalendarOutput(byte[] bytes, FunambolLogger log) {
		String s, lines[];
		StringBuffer buf;
		int i;
		
		buf = new StringBuffer();
		s = new String(bytes);
		
		// FIXME: 
		// try to convert VALARMS to AALARMS when syncing from sogo to funambol client
		// currently unimplemented (it is a 1:1 copy)
		// Problem: sanitizevCalendarOutput is never called, so it wouldn't help anyway.
		s = vAlarm2AAlarm(s, log);
		
		lines = s.split("\r\n");
		
		for (i = lines.length-1; i >= 0; i--) {
			
			s = lines[i];

			// We strip any empty AALARM as they'll cause SyncJe v2.37 and below to fail
			// upon synchronization
			if (s.startsWith("AALARM:;;;")) continue;

			buf.insert(0, "\r\n");
			buf.insert(0, s);
		}
		
		return buf.toString();
	}

	public static String vAlarm2AAlarm(String s, FunambolLogger log) {
		// TODO
		// currently this function does nothing, return value is equal to input
		// value s.

		log.info("in vAlarm2AAlarm(), s on input:".concat(s));
		String ret = "", delim, line, lines[];
		try {
			// We check to see how do we split our lines, using \r\n or simply
			// \n.
			if (s.indexOf("\r\n") >= 0) {
				delim = "\r\n";
			} else {
				delim = "\n";
			}
			lines = s.split(delim);
			for (int i = 0; i <= lines.length - 1; i++) {

				line = lines[i];

				// find the VALARM start line:
				if (line.startsWith("BEGIN:VALARM")) {
					// log.info("1st VALARM line:".concat(line));
					// FIXME:
					// do something more useful than
					ret = ret.concat(line).concat(delim);
				} else {
					// log.info("line:".concat(line));
					ret = ret.concat(line).concat(delim);
				}
			}
		} catch (Exception e) {
			log.error("Exception occured in vAlarm2AAlarm(): " + e.toString(), e);
			return s;
		}
		log.info("after vAlarm2AAlarm(), ret value is:".concat(ret));
		return ret;
	}
	
	/**
	 * 
	 * This method is used to cleanup stuff in the vCard before it's sent to the
	 * SOGo database.
	 * 
	 * @param bytes
	 * @param log
	 * @return
	 */
	public static String sanitizevCardOutput(byte[] bytes, Contact c, SyncContext context, FunambolLogger log) {
		String delim, lines[], givenname, fn, sn, s;
		StringBuffer buf;
		boolean b, empty;
		int x, y, i, j;
		
		buf = new StringBuffer(new String(bytes));
		
		// We check to see how do we split our lines, using \r\n or simply \n.
		if (buf.toString().indexOf("\r\n") >= 0) {
			delim = "\r\n";
		} else {
			delim = "\n";
		}
		
		// We check if FN: is present.
		givenname = c.getName().getFirstName().getPropertyValueAsString();
		fn = c.getName().getDisplayName().getPropertyValueAsString();
		sn = c.getName().getLastName().getPropertyValueAsString();
		

		if (fn == null || fn.trim().length() == 0)
			fn = givenname + " " + sn;
		
	    lines = buf.toString().split(delim);
	    
	    buf = new StringBuffer();
	    b = false;
	    
		for (i = 0; i < lines.length; i++) {

			// We strip empty properties - this is just brained
			// but causes massive headache to all clients. We strip
			// stuff like:
			//   ADR: and 
			//   ADR;HOME:;;;;;;
			//
			// We MUST make sure we don't strip empty properties followed by
			// folded lines, for example :
			//  PHOTO;TYPE=JPEG;ENCODING=b:
			//    /9j/4AAQSkZJRgABAQAAAQABAAD/4QBYRXhpZgAATU0AKgAAAAgAAgESAAMAAAABAAEAAIdp
			//    AAQAAAABAAAAJgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAQKADAAQAAAABAAAAQAAA
			//    AAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB			
			// FIXME: do that for calendar stuff too?
		    empty = true;
		    
		    s = lines[i].trim();
			x = s.indexOf(':');
			y = s.length();
			
			for (j = x+1; j < y; j++)
				if (s.charAt(j) != ';') {
					empty = false;
					break;
				}
			
			// If empty, let's check for a folded line
			// before deciding if we strip it.
			if (empty && 
				i < lines.length-2 &&
				!(lines[i+1].startsWith(" ") || lines[i+1].startsWith("\t"))) {
				continue;
			}
			
			// It looks like once the contact is merged, "\r\n " gets replaced with "   "
			// (three spaces) which breaks the iPhone sync. So we replace things back
			// to fix this.
			if (SOGoUtilities.isIPhone(context) && s.toUpperCase().startsWith("PHOTO")) {
				
				// Check if we have a folded line, if so, we ignore the PHOTO issue
				if (i+1 < lines.length && !lines[i+1].startsWith(" ")) {
					lines[i] = lines[i].replaceAll("  ", delim);
				}
			}
			
			// We look for FN, if not there, we will add it so
			// SOGo and Thunderbird will display cards correctly
			if (lines[i].startsWith("FN:") || lines[i].startsWith("FN;"))
				b = true;
			
			// If we reached the end and haven't seen it...
			if (!b && i == lines.length-1) {
				buf.append("FN:");
				buf.append(fn);
				buf.append(delim);
			}
			
			buf.append(lines[i]);
			buf.append(delim);
		}	
		
		return buf.toString();
	}
	
	/**
	 * 
	 * This method is called prior to sending data back to mobile
	 * devices.
	 * 
	 * @param bytes
	 * @return
	 */
	public static String sanitizevCardInput(byte[] bytes, SyncContext context, FunambolLogger log) {
		String s, delim, email, lines[], prefs[] = {";TYPE=work:", ";TYPE=home:", ";TYPE=cell:", ";TYPE=fax:", ";TYPE=pager:"};
		StringBuffer buf;
		boolean b, empty;
		int x, y, i, j;
		
		buf = new StringBuffer(new String(bytes));
		
		// We check to see how do we split our lines, using \r\n or simply \n.
		if (buf.toString().indexOf("\r\n") >= 0) {
			delim = "\r\n";
		} else {
			delim = "\n";
		}
		
		// We replace:
		// TEL;TYPE=PREF,WORK:+1234567890
		// with:
	    // TEL;TYPE=PREF;TYPE=WORK:+1234567890
	    x = buf.indexOf("TYPE=PREF,WORK");
	    
	    while (x >= 0) {
			buf.replace(x, x+14, "TYPE=PREF;TYPE=WORK");
	    	x = buf.indexOf("TYPE=PREF,WORK");
	    }
	    
	    // We replace:
	    // ;TYPE=work:
	    // with:
	    // ;TYPE=WORK:
	    // and same for "home" and "cell".
	    for (i = 0; i < prefs.length; i++) {
	    	x = buf.indexOf(prefs[i]);
	    	
	    	while (x> 0) {
	    		buf.replace(x, x+prefs[i].length(), prefs[i].toUpperCase());
	    		x = buf.indexOf(prefs[i], x+1);
	    	}
	    }
	    	    
	    
		// We check if N: is present. It's a requirement in vCard 2.1 and some clients will break
		// (like Nexthaus SyncJe) if that property isn't present.
	    lines = buf.toString().split(delim);
	    
	    buf = new StringBuffer();
	    email = null;
	    b = false;
	    
		for (i = 0; i < lines.length; i++) {
			
			// We strip empty properties - this is just brained
			// but causes massive headache to all clients. We strip
			// stuff like:
			//   ADR: and 
			//   ADR;HOME:;;;;;;
			// FIXME: do that for calendar stuff too?
		    empty = true;
			s = lines[i].trim(); 
			x = s.indexOf(':');
			y = s.length();
			
			for (j = x+1; j < y; j++)
				if (s.charAt(j) != ';') {
					empty = false;
					break;
				}
			
			// If empty, let's check for a folded line
			// before deciding if we strip it.
			if (empty && 
				i < lines.length-2 &&
				!(lines[i+1].startsWith(" ") || lines[i+1].startsWith("\t"))) {
				continue;
			}
			
			// We look for FN, if not there, we will add it so
			// SOGo and Thunderbird will display cards correctly
			if (lines[i].startsWith("FN:") || lines[i].startsWith("FN;"))
				b = true;

			
			if (lines[i].startsWith("N:") || lines[i].startsWith("N;"))
				b = true;
			
			try {
				if (lines[i].startsWith("EMAIL")) {
					x  = lines[i].indexOf('@');
					
					if (x > 0) {
						char ch;
						int c;
					
						for (c = x-1; c >= 0; c--) {
							ch = lines[i].charAt(c);
							if (!Character.isLetterOrDigit(ch) && ch != '.') {
								email = lines[i].substring(c+1, c);
								break;
							}
						}
					}
				}
			} catch (Exception e) {
				email = null;
			}
			
			// If we reached the end and haven't seen it...
			if (!b && i == lines.length-2) {
				buf.append("N:");
				if (email != null) {
					buf.append(email);
				} else {
					buf.append("Unknown");
				}
				buf.append(delim);
			}
			
			buf.append(lines[i]);
			buf.append(delim);
		}
		
		log.info("Sanitized content: " + buf.toString());
		
		return buf.toString();
	}
	
	/**
	 * 
	 * @param t
	 */
	public static void sanitizeSIFTask(Task t) {
		Property prop;
		
		prop = t.getComplete();
		
		if (prop.getPropertyValue() instanceof String) {
			boolean b;
			
			b = (((String)prop.getPropertyValue()).equalsIgnoreCase("1"));
			
			prop = new com.funambol.common.pim.common.Property();
			prop.setPropertyValue(new Boolean(b));
			
			t.setComplete(prop);	
		}
	}

    /**
     * Modify a Funambol calendar object so that it can be saved as iCalendar.
     * This method is used to work around Funambol bugs, and should be removed when the
     * version required by the connector has fixed these bugs.
     *
     * @param calendar The Calendar object to clean up
     */
    public static void sanitizeFunambolCalendar(Calendar calendar) {
        // Must add property percentComplete, this bug is fixed in Funambol 8.5 snapshots
        Task task;
        task = calendar.getTask();
        if (task != null) {
            if (task.getPercentComplete() == null) {
                // Note that we don't have to set a value, that the property exists is enough
                task.setPercentComplete(new Property());
            }
        }
    }
}
